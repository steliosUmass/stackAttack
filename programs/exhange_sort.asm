.VAR ARRAY_LENGTH 100
.VAR ARRAY_LOCATION 100

# push index i inital value
PUSH_VAL 0

# push index j inital value
OUTER_LOOP: DUP 0
PUSH_VAL 1
ADD

# GET VALUE at ARRAY[ i ]
DUP 1
PUSH_VAL ARRAY_LOCATION
ADD
LDR_32
PUSH

# first check if j is equal to i
INNER_LOOP: PUSH_VAL FINISHED
DUP 3
PUSH_VAL ARRAY_LENGTH
EQ
JMP_IF_1

# GET VALUE at ARRAY[ j ]
DUP 1
PUSH_VAL ARRAY_LOCATION
ADD
LDR_32
PUSH

# PUSH VALUE TO BRANCH TOO
PUSH_VAL EXCHANGE

# COPY ARRAY[ i] and ARRAY[ j ] FOR CMP
DUP 3
DUP 3

# DO CMP and branch
LT
JMP_IF_1

# No exchanged need, pop ARRAY[ j ] and JMP to end of loop
POP
PUSH_VAL END_INNER
JMP

# SWAP ARRAY[ i ] and ARRAY[ j ]
EXCHANGE: SWAP 1
# POP ARRAY[ i ] and store it at ARRAY[ j ]
POP
DUP 1
PUSH_VAL ARRAY_LOCATION
ADD
STR_32

# POP copy of ARRAY[ j ] and store at ARRAY[ i ]
DUP 0
POP
DUP 2
PUSH_VAL ARRAY_LOCATION
ADD
STR_32

# increment j here and see if we should loop again
END_INNER: SWAP 1
PUSH_VAL 1
ADD
SWAP 1
PUSH_VAL INNER_LOOP
DUP 3
PUSH_VAL ARRAY_LENGTH
EQ
JMP_IF_0

# POP off ARRAY[ i ] and j
POP
POP

# increment i here and see if we should loop again
PUSH_VAL 1
ADD
PUSH_VAL OUTER_LOOP
DUP 2
PUSH_VAL ARRAY_LENGTH
EQ
JMP_IF_0

# finally halt
FINISHED: HALT

# PUT array in memory at location 100
.ADDR ARRAY_LOCATION

.LOAD 105 196 716 329 309 248 681 598 661 43 400 613 546 0 22 22 485 550 226 730 725 31 726 609 975 338 878 683 486 619 972 909 453 409 608 191 261 541 604 884 136 505 927 658 819 948 19 84 351 989 647 728 774 976 796 609 990 931 772 375 267 548 289 340 640 471 722 409 630 468 46 671 242 947 943 27 888 95 638 600 297 715 95 916 454 210 956 679 448 779 212 994 388 601 208 226 346 650 729 820 
